# マルチタスク性とセマフォ利用の説明

## マルチタスク性（このゲームが「同時進行」に見える理由）
- このプログラムは `set_task()` で複数タスクを登録し、`begin_sch()` のスケジューラで切り替えながら動作する。
- 入力・ゲーム進行・描画が役割分離され、時間を分け合って並行に進む構造になっている。
- 単一タスクなら「入力→更新→描画→入力→…」を1本の流れで処理できるが、ここでは別タスクが独立に進行し合図しながら動くため「一筆書きで表せない」実行になる。
- よって、スクショの定義（時間を逆らわずに一筆書き不可＝マルチタスク）に一致する。

## 各タスクの役割（`three/shooting.c`）
- `task_input_p1` / `task_input_p2`
  - ポート0/1からキー入力を読み、移動や発射のフラグを `g.input_dir` / `g.input_fire` に書き込む。
  - 入力は常時受付で、ゲーム更新とは独立に走る。
- `task_game`
  - 入力フラグを取り込み、プレイヤー移動、弾生成・移動、当たり判定、スコア更新を行う。
  - 画面に変更がある場合だけ描画タスクに更新を依頼する。
- `task_render`
  - `g` の状態をスナップショットし、差分描画で画面を更新する。
  - 描画が完了したらゲームタスクへ「完了」を通知する。

## セマフォの使い方（安全な並行動作のため）
- `SEM_MUTEX`（排他制御）
  - 目的: 共有データ `g` を同時に複数タスクが触って壊すのを防ぐ。
  - 使い方:
    - 入力タスクが `g.input_*` を書くときに `P(SEM_MUTEX)` でロック、終わったら `V(SEM_MUTEX)`。
    - ゲームタスクが `g` を読み書きするときもロック。
    - 描画タスクが `g` をコピーする瞬間もロック。
  - これにより、入力中にゲームが更新して値が壊れるなどの競合を防止する。
- `SEM_RENDER` / `SEM_RENDER_DONE`（ゲーム更新 ↔ 描画の同期）
  - 目的: 更新と描画のタイミングを揃える。
  - 流れ:
    - ゲームタスクが「画面更新が必要」と判断したら `V(SEM_RENDER)`。
    - 描画タスクは `P(SEM_RENDER)` で待ち、描画を実行。
    - 描画完了後に `V(SEM_RENDER_DONE)` を出し、ゲームタスクが `P(SEM_RENDER_DONE)` で完了を待つ。
  - これにより、更新が連続して描画が追いつかない、描画中に状態が変わるといったずれを防止する。

## まとめ
- このゲームは入力・更新・描画を別タスクとして同時進行させ、セマフォで共有データの排他制御と描画同期を行うことで、マルチタスク環境でも安全かつ滑らかな動作を実現している。
